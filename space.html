<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P2P Chat - Single HTML</title>
<style>
  :root{
    --bg:#0f1115; --card:#151926cc; --muted:#99a2b2; --text:#e7ebf3; --accent:#6ea8fe;
    --ok:#2ecc71; --bad:#ff6b6b; --chip:#232938; --bubble-me:#2a3450; --bubble-you:#1f2636;
    --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.02);
    --radius:16px; --radius-sm:10px;
  }
  [data-theme="light"]{
    --bg:#f4f6fb; --card:#ffffffcc; --muted:#5a667c; --text:#111827; --accent:#2563eb;
    --ok:#10b981; --bad:#ef4444; --chip:#eef2ff; --bubble-me:#dbeafe; --bubble-you:#f3f4f6;
    --shadow: 0 10px 30px rgba(0,0,0,.08), inset 0 1px 0 rgba(255,255,255,.6);
  }
  html,body{height:100%}
  body{
    margin:0; background: radial-gradient(1200px 1200px at 10% -10%, #1b2030 0%, var(--bg) 40%) no-repeat fixed;
    color:var(--text); font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    transition: background .3s ease, color .3s ease;
  }
  [data-theme="light"] body{
    background: radial-gradient(1200px 1200px at 90% -10%, #e8f0ff 0%, var(--bg) 40%) no-repeat fixed;
  }
  .wrap{max-width:1100px; margin:40px auto; padding:0 16px;}
  .app{display:grid; grid-template-columns: 340px 1fr; gap:18px}
  @media (max-width: 900px){ .app{grid-template-columns: 1fr} }

  .card{
    background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow); backdrop-filter: blur(10px);
    border:1px solid rgba(255,255,255,.08);
  }
  header{
    display:flex; align-items:center; justify-content:space-between; gap:10px; padding:18px 20px;
  }
  .title{display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.3px;}
  .badge{
    padding:5px 10px; border-radius:999px; font-size:12px; background:var(--chip); color:var(--muted);
    display:inline-flex; align-items:center; gap:.5ch; border:1px solid rgba(255,255,255,.06);
  }
  .status-dot{width:8px; height:8px; border-radius:50%; background:var(--bad); box-shadow:0 0 0 3px rgba(255,107,107,.15);}
  .status-dot.ok{background:var(--ok); box-shadow:0 0 0 3px rgba(46,204,113,.15);}
  .controls{display:flex; align-items:center; gap:8px}
  .btn{
    border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.06));
    color:var(--text); padding:9px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    transition: transform .05s ease, filter .2s ease; user-select:none;
  }
  .btn:active{ transform: scale(.98); }
  .btn.primary{ background: linear-gradient(180deg, var(--accent), color-mix(in srgb, var(--accent) 70%, black)); border-color:transparent; color:white; }
  .btn.ghost{ background:transparent }
  .btn.small{ padding:6px 9px; font-size:12px }
  .field{display:flex; flex-direction:column; gap:6px; margin:10px 0 14px}
  label{font-size:12px; color:var(--muted)}
  textarea, input[type="text"]{
    width:100%; padding:12px 12px; background:#0e1524; border:1px solid rgba(255,255,255,.06);
    border-radius:12px; color:var(--text); outline:none; resize:vertical; min-height:44px;
  }
  [data-theme="light"] textarea, [data-theme="light"] input[type="text"]{
    background:#f8fafc; border-color: #e5e7eb;
  }
  textarea.sdp{min-height:100px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px}
  .chat{display:flex; flex-direction:column; height:72vh}
  .messages{flex:1; overflow:auto; padding:10px 16px 2px 16px; scroll-behavior:smooth}
  .row{display:flex; margin:8px 0}
  .bubble{
    max-width:68%; padding:10px 14px; border-radius:16px; box-shadow: var(--shadow);
    white-space:pre-wrap; word-break:break-word;
  }
  .me{justify-content:flex-end}
  .me .bubble{background:var(--bubble-me); border-bottom-right-radius:6px}
  .you .bubble{background:var(--bubble-you); border-bottom-left-radius:6px}
  .meta{display:flex; align-items:center; gap:8px}
  .time{font-size:11px; color:var(--muted); margin-top:4px}
  .composer{display:flex; gap:8px; padding:12px; border-top:1px solid rgba(255,255,255,.08)}
  .composer input{flex:1}
  .side{padding:14px}
  .section{padding:14px; border-top:1px dashed rgba(255,255,255,.08)}
  .tips{font-size:12px; color:var(--muted)}
  .chip{font-size:11px; padding:4px 8px; border-radius:999px; background:var(--chip); border:1px solid rgba(255,255,255,.08)}
  .copyrow{display:flex; gap:8px}
  .hr{height:1px; background:linear-gradient(90deg, transparent, rgba(255,255,255,.1), transparent); margin:12px 0}
  .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:var(--chip); padding:1px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.08)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <!-- Left: Connection / Settings -->
      <div class="card side">
        <header>
          <div class="title">🔗 接続</div>
          <div class="badge"><span id="dot" class="status-dot"></span><span id="state">Disconnected</span></div>
        </header>

        <div class="section">
          <div class="field">
            <label>あなたの表示名</label>
            <div style="display:flex; gap:8px">
              <input id="nickname" type="text" placeholder="例）Taro" />
              <button class="btn small" id="saveName">保存</button>
            </div>
          </div>

          <div class="field">
            <label>役割を選択</label>
            <div class="meta" style="gap:8px">
              <button class="btn primary small" id="btnOffer">ホスト（Offerを作成）</button>
              <button class="btn small" id="btnAnswer">ゲスト（Answerを作成）</button>
              <button class="btn ghost small" id="btnReset">リセット</button>
            </div>
          </div>

          <div class="hr"></div>

          <div class="field">
            <label>あなたのSDP（生成されたら相手へ渡す）</label>
            <div class="copyrow">
              <textarea id="localSdp" class="sdp" readonly placeholder="ここに自動出力されます"></textarea>
            </div>
            <div class="meta" style="gap:8px; margin-top:6px">
              <button class="btn small" id="copyLocal">コピー</button>
              <span class="tips">※ 長い文字列は自動的にBase64化しています</span>
            </div>
          </div>

          <div class="field">
            <label>相手のSDP（相手から受け取った文字列を貼る）</label>
            <textarea id="remoteSdp" class="sdp" placeholder="相手のSDP文字列（Base64可）を貼って下さい"></textarea>
            <div class="meta" style="gap:8px; margin-top:6px">
              <button class="btn primary small" id="applyRemote">相手SDPを適用</button>
              <button class="btn ghost small" id="clearRemote">クリア</button>
            </div>
          </div>

          <div class="hr"></div>
          <div class="meta" style="justify-content:space-between">
            <div class="tips">
              <span class="chip">P2P / WebRTC</span>
              <span class="chip">手動シグナリング</span>
              <span class="chip">暗号化</span>
            </div>
            <button class="btn small" id="toggleTheme">🌗 テーマ</button>
          </div>
        </div>

      </div>

      <!-- Right: Chat -->
      <div class="card">
        <header>
          <div class="title">💬 P2P Chat <span id="role" class="chip">未選択</span></div>
          <div class="controls">
            <button class="btn small" id="saveLog">ログ保存</button>
            <button class="btn small" id="clearChat">履歴クリア</button>
          </div>
        </header>

        <div class="chat">
          <div id="messages" class="messages"></div>
          <div class="composer">
            <input id="input" type="text" placeholder="メッセージを入力…" disabled />
            <button class="btn primary" id="send" disabled>送信</button>
          </div>
        </div>

        <div class="section tips">
          使い方：<strong>ホスト</strong>が「Offerを作成」→ 出力を相手へ。<strong>ゲスト</strong>は相手SDPに貼って「Answerを作成」→ 出力をホストへ返す → ホストは相手SDPを適用。<br/>
          <span class="kbd">Enter</span> 送信 / <span class="kbd">Shift+Enter</span> 改行。
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // --- UI helpers ---
  const $ = sel => document.querySelector(sel);
  const dot = $('#dot'), stateEl = $('#state'), roleEl = $('#role');
  const localSdpEl = $('#localSdp'), remoteSdpEl = $('#remoteSdp');
  const input = $('#input'), sendBtn = $('#send'), messages = $('#messages');
  const nickname = $('#nickname');

  const setStatus = (txt, ok=false) => {
    stateEl.textContent = txt;
    dot.classList.toggle('ok', ok);
  };
  const now = () => new Date();
  const timeStr = () => {
    const d = now();
    const pad = n => String(n).padStart(2,'0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  const addMsg = (text, me=false, name='You') => {
    const row = document.createElement('div');
    row.className = 'row ' + (me ? 'me' : 'you');
    const b = document.createElement('div');
    b.className = 'bubble';
    const who = document.createElement('div');
    who.className = 'meta'; who.style.fontSize='12px'; who.style.color='var(--muted)';
    who.textContent = me ? (storedName() || 'Me') : name;
    const t = document.createElement('div');
    t.textContent = text;
    const ts = document.createElement('div'); ts.className='time'; ts.textContent = timeStr();
    b.appendChild(who); b.appendChild(t); b.appendChild(ts);
    row.appendChild(b);
    messages.appendChild(row);
    messages.scrollTop = messages.scrollHeight;
  };
  const storedName = () => localStorage.getItem('p2pname') || '';
  const setTheme = (mode) => {
    document.documentElement.setAttribute('data-theme', mode);
    localStorage.setItem('p2ptheme', mode);
  };

  // persist name & theme
  nickname.value = storedName();
  const savedTheme = localStorage.getItem('p2ptheme') || (window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
  setTheme(savedTheme);

  // --- WebRTC core ---
  let pc = null, dc = null, role = null;
  const iceServers = [{urls:'stun:stun.l.google.com:19302'}];

  const reset = () => {
    try { if (dc) dc.close(); } catch {}
    try { if (pc) pc.close(); } catch {}
    pc = null; dc = null; role = null;
    roleEl.textContent = '未選択';
    input.disabled = true; sendBtn.disabled = true;
    localSdpEl.value = ''; remoteSdpEl.value = '';
    setStatus('Disconnected', false);
  };

  const newPc = () => {
    const _pc = new RTCPeerConnection({ iceServers, iceCandidatePoolSize: 0 });
    _pc.onconnectionstatechange = () => {
      const s = _pc.connectionState;
      if (s === 'connected'){ setStatus('Connected', true); input.disabled=false; sendBtn.disabled=false; }
      else if (s === 'disconnected' || s === 'failed' || s === 'closed'){ setStatus('Disconnected', false); input.disabled=true; sendBtn.disabled=true; }
    };
    _pc.oniceconnectionstatechange = () => {
      // For visibility, but not strictly necessary.
      // console.log('ICE:', _pc.iceConnectionState);
    };
    _pc.onicecandidateerror = (e) => {
      console.warn('ICE candidate error', e);
    };
    return _pc;
  };

  const waitIceDone = pc => new Promise(res => {
    if (pc.iceGatheringState === 'complete') return res();
    const check = () => { if (pc.iceGatheringState === 'complete') { pc.removeEventListener('icegatheringstatechange', check); res(); } };
    pc.addEventListener('icegatheringstatechange', check);
  });

  const encodeSDP = (desc) => {
    const json = JSON.stringify({ sdp: desc.sdp, type: desc.type });
    return btoa(unescape(encodeURIComponent(json))); // Base64
  };
  const decodeSDP = (txt) => {
    let raw = txt.trim();
    if (!raw) throw new Error('空のSDPです');
    if (raw.startsWith('{')) return JSON.parse(raw);
    try {
      const json = decodeURIComponent(escape(atob(raw)));
      return JSON.parse(json);
    } catch {
      // Try as plain SDP
      return { type: raw.includes('a=group:BUNDLE') ? 'offer' : 'answer', sdp: raw };
    }
  };

  async function createOfferFlow(){
    reset();
    role = 'host'; roleEl.textContent='ホスト';
    pc = newPc();
    dc = pc.createDataChannel('chat', { ordered: true });
    wireDataChannel(dc);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await waitIceDone(pc);
    localSdpEl.value = encodeSDP(pc.localDescription);
    setStatus('Waiting for Answer…', false);
  }

  async function createAnswerFlow(){
    if (!pc) pc = newPc();
    role = 'guest'; roleEl.textContent='ゲスト';
    pc.ondatachannel = (ev) => {
      dc = ev.channel;
      wireDataChannel(dc);
    };
    // remote must be set first
    const remote = remoteSdpEl.value.trim();
    if (!remote) { alert('先に「相手のSDP」を貼ってください（ホストが作成したOffer）'); return; }
    const r = decodeSDP(remote);
    await pc.setRemoteDescription(new RTCSessionDescription(r));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await waitIceDone(pc);
    localSdpEl.value = encodeSDP(pc.localDescription);
    setStatus('Answer ready. これを相手へ渡してください', false);
  }

  async function applyRemote(){
    if (!pc) {
      // If user is host path: they created offer already, so pc exists.
      pc = newPc();
    }
    const raw = remoteSdpEl.value.trim();
    if (!raw){ alert('相手SDPを貼ってください'); return; }
    const r = decodeSDP(raw);
    await pc.setRemoteDescription(new RTCSessionDescription(r));
    setStatus('Remote SDP applied', false);
  }

  function wireDataChannel(ch){
    ch.onopen = () => {
      setStatus('Connected', true);
      input.disabled = false; sendBtn.disabled = false;
      addMsg('接続しました。チャットを開始できます。', false, 'System');
      // Send hello with name
      const hello = { t:'hello', name: storedName() || 'Peer' };
      ch.send(JSON.stringify(hello));
    };
    ch.onmessage = (ev) => {
      try{
        const data = JSON.parse(ev.data);
        if (data.t === 'hello') {
          // store peer name for display
          window._peerName = data.name || 'Peer';
          return;
        }
      }catch{}
      addMsg(ev.data, false, window._peerName || 'Peer');
    };
    ch.onclose = () => setStatus('Disconnected', false);
    ch.onerror = () => setStatus('Error', false);
  }

  function send(){
    const txt = input.value;
    if (!txt || !dc || dc.readyState!=='open') return;
    dc.send(txt);
    addMsg(txt, true);
    input.value = '';
  }

  // --- events ---
  $('#btnOffer').addEventListener('click', createOfferFlow);
  $('#btnAnswer').addEventListener('click', createAnswerFlow);
  $('#applyRemote').addEventListener('click', applyRemote);
  $('#clearRemote').addEventListener('click', () => remoteSdpEl.value='');
  $('#btnReset').addEventListener('click', reset);
  $('#send').addEventListener('click', send);
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); send(); }
  });
  $('#copyLocal').addEventListener('click', async () => {
    if (!localSdpEl.value) return;
    await navigator.clipboard.writeText(localSdpEl.value);
    const old = event.target.textContent; event.target.textContent='✓ コピーしました';
    setTimeout(()=> event.target.textContent=old, 1200);
  });
  $('#saveLog').addEventListener('click', () => {
    const text = [...messages.querySelectorAll('.row')].map(r=>{
      const who = r.classList.contains('me') ? (storedName()||'Me') : (window._peerName||'Peer');
      const msg = r.querySelector('.bubble').childNodes[1].textContent;
      const tm  = r.querySelector('.time').textContent;
      return `[${tm}] ${who}: ${msg}`;
    }).join('\n');
    const blob = new Blob([text], {type:'text/plain'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = 'p2p-chat-log.txt'; a.click(); URL.revokeObjectURL(a.href);
  });
  $('#clearChat').addEventListener('click', () => { messages.innerHTML=''; });
  $('#saveName').addEventListener('click', () => {
    localStorage.setItem('p2pname', nickname.value.trim());
    addMsg(`あなたの表示名を「${storedName()||'Me'}」として保存しました`, false, 'System');
  });
  $('#toggleTheme').addEventListener('click', () => {
    const cur = document.documentElement.getAttribute('data-theme') || 'dark';
    setTheme(cur==='dark' ? 'light' : 'dark');
  });

  // greet
  addMsg('まずはホスト/ゲストを選んで接続しましょう。', false, 'Guide');
})();
</script>
</body>
</html>