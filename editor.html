<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Drift Touge 2P — JS Physics</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #0a0c10;
    --road: #1a1f27;
    --lane: #2b3240;
    --edge: #aeb7c6;
    --tree: #0f3a2f;
    --wall: #9aa3ad;
    --hud: #e7edf6;
    --p1: #46d1ff;
    --p2: #ff6a66;
    --trail1: rgba(70,209,255,0.18);
    --trail2: rgba(255,106,102,0.18);
    --smoke: rgba(240,240,240,0.08);
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--hud); font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif;
    height: 100%;
    overflow: hidden;
  }
  #ui {
    position: absolute; top: 8px; left: 8px; right: 8px; display: flex; gap: 8px; z-index: 10; pointer-events: none;
  }
  .panel {
    background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.08); border-radius: 8px; padding: 8px 12px; backdrop-filter: blur(8px);
  }
  .legend { display:flex; gap:16px; flex-wrap:wrap; }
  .chip { display:flex; align-items:center; gap:8px; }
  .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
  .p1 { background: var(--p1); }
  .p2 { background: var(--p2); }
  #canvas { width: 100vw; height: 100vh; display:block; }
  .footer {
    position:absolute; bottom:8px; left:8px; right:8px; display:flex; justify-content:space-between; gap:8px; pointer-events:none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
  <div class="panel">
    <div><strong>Drift Touge 2P</strong> — Downhill, point‑to‑point</div>
    <div class="legend" style="margin-top:6px;">
      <div class="chip"><span class="dot p1"></span>P1: W/A/S/D + Space + Shift + C</div>
      <div class="chip"><span class="dot p2"></span>P2: Arrows + Right Ctrl + Right Shift + M</div>
    </div>
  </div>
  <div class="panel" id="raceInfo">Loading…</div>
</div>
<div class="footer">
  <div class="panel" id="p1HUD">P1</div>
  <div class="panel" id="p2HUD">P2</div>
</div>
<script>
(function(){
  // ------------------------
  // Parameters (tuning keys)
  // ------------------------
  const Params = {
    dt: 1/120,                  // physics step
    trackWidth: 18,             // meters, paved width
    laneMarkGap: 48,            // dashed center line pattern
    treeDensity: 0.12,          // trees per meter of centerline
    wallElasticity: 0.25,       // bounce energy on guardrail hit
    offroadFriction: 2.8,       // drag multiplier off road
    driftAngleMin: 10 * Math.PI/180,
    driftSpeedMin: 8,           // m/s (≈ 29 km/h)
    proximityMax: 6,            // meters for max proximity bonus
    finishBonus: 2000,
    chaseCamLag: 0.14,          // lower = tighter camera
    split: true,                // true = split screen, false = shared cam
  };

  // Car physics defaults (bicycle model + slip-angle lateral forces)
  function makeCar(color) {
    return {
      // Pose & kinematics
      x: 0, y: 0, yaw: 0, vx: 0, vy: 0, yawRate: 0,
      // Inputs
      steer: 0, throttle: 0, brake: 0, handbrake: 0, clutchKick: 0,
      // Visual
      color, trail: [], smoke: [],
      // Scores
      driftScore: 0, proximityScore: 0, wallHits: 0, cleanTime: 0, finished: false, time: 0,
      // Car params
      mass: 1250, Iz: 1500,        // inertia approx
      wheelbase: 2.6, lf: 1.2, lr: 1.4,
      Cf: 65000, Cr: 78000,        // cornering stiffness (rear stiffer for natural oversteer w/ handbrake)
      mu: 1.6,                     // tire-road friction
      drag: 0.12, rr: 12.0,        // aero drag and rolling resistance
      engineForce: 9200,           // base engine force at full throttle
      brakeForce: 9000, handbrakeForce: 2000,
      steerRate: 3.6, maxSteer: 0.78, // ~45 deg
      // Helpers
      boostTimer: 0
    };
  }

  // ------------------------
  // Track: Japanese touge polyline
  // ------------------------
  // Designed as a downhill snake: hairpins, sweepers, S-curves.
  const Track = {
    points: [],
    length: 0,
    sAccum: [],
    walls: [], // guardrails (computed from offset polylines)
  };

  function buildTrack() {
    // Create a mountainous polyline with elevation implied by gradient coloring (2D physics)
    const pts = [];
    // Start straight
    pts.push([0,0],[0,-50],[-10,-140],[-28,-220],[-36,-270]);
    // First hairpins
    pts.push([-30,-320],[-5,-380],[40,-430],[90,-480],[110,-530]);
    pts.push([95,-590],[40,-650],[-15,-690],[-65,-730],[-110,-770]);
    // S sweepers
    pts.push([-140,-820],[-120,-880],[-60,-930],[30,-960],[110,-980],[175,-1020]);
    // Tight mid-section
    pts.push([200,-1080],[170,-1150],[100,-1210],[25,-1240],[-60,-1260],[-140,-1290]);
    // Long left + hairpin right
    pts.push([-210,-1350],[-240,-1420],[-230,-1490],[-180,-1560],[-100,-1620],[-10,-1660],[90,-1680]);
    // Final serpentine to finish
    pts.push([150,-1720],[135,-1765],[80,-1810],[10,-1840],[-60,-1865],[-130,-1910],[-170,-1980],[-160,-2050],[-120,-2110],[-70,-2140],[0,-2160]);

    // Scale to meters
    const scale = 1.3;
    Track.points = pts.map(([x,y])=>[x*scale,y*scale]);

    // Arc-length parameterization
    Track.sAccum = [0];
    for (let i=1;i<Track.points.length;i++){
      const a = Track.points[i-1], b = Track.points[i];
      const dx=b[0]-a[0], dy=b[1]-a[1];
      Track.sAccum[i] = Track.sAccum[i-1] + Math.hypot(dx,dy);
    }
    Track.length = Track.sAccum[Track.sAccum.length-1];

    // Guardrail offsets (simple normal offset of polyline)
    const w = Params.trackWidth*0.5 + 1.8; // a bit beyond road
    const left = [], right = [];
    for (let i=0;i<Track.points.length;i++){
      const p = Track.points[i];
      const dir = tangentAt(i);
      const nx = -dir[1], ny = dir[0];
      left.push([p[0]+nx*w, p[1]+ny*w]);
      right.push([p[0]-nx*w, p[1]-ny*w]);
    }
    // Convert to segments for collision
    Track.walls = [];
    function addSegments(arr){
      for (let i=1;i<arr.length;i++){
        const a = arr[i-1], b = arr[i];
        Track.walls.push({ax:a[0], ay:a[1], bx:b[0], by:b[1]});
      }
    }
    addSegments(left);
    addSegments(right);
    // Sprinkle trees (static decoration) near outer sides
    buildTrees(left, right);
  }

  function tangentAt(i){
    const p0 = Track.points[Math.max(0,i-1)];
    const p1 = Track.points[Math.min(Track.points.length-1,i+1)];
    const dx = p1[0]-p0[0], dy = p1[1]-p0[1];
    const L = Math.hypot(dx,dy)||1;
    return [dx/L, dy/L];
  }

  // Precompute trees
  const Trees = [];
  function buildTrees(left, right){
    Trees.length = 0;
    // Choose side outward normal fluctuations
    const total = Math.floor(Track.length * Params.treeDensity);
    for (let i=0;i<total;i++){
      const t = i/total*(Track.points.length-1);
      const idx = Math.floor(t);
      const frac = t - idx;
      const p = lerp2(Track.points[idx], Track.points[idx+1], frac);
      const dir = tangentAt(idx);
      const nx = -dir[1], ny = dir[0];
      const side = (Math.random()<0.5)?1:-1;
      const d = Params.trackWidth*0.7 + 6 + Math.random()*10;
      Trees.push({
        x: p[0] + nx*d*side + (Math.random()-0.5)*3,
        y: p[1] + ny*d*side + (Math.random()-0.5)*3,
        r: 1.0 + Math.random()*1.5
      });
    }
  }

  function lerp2(a,b,t){ return [a[0]+(b[0]-a[0])*t, a[1]+(b[1]-a[1])*t]; }

  // ------------------------
  // Projection onto centerline (for progress, distance, proximity)
  // ------------------------
  function projectToTrack(x,y){
    // Find nearest segment (linear scan; ok for demo)
    let bestD = Infinity, bestS = 0, bestP = [0,0], bestN = [0,0], bestT=0;
    for (let i=1;i<Track.points.length;i++){
      const a = Track.points[i-1], b = Track.points[i];
      const abx = b[0]-a[0], aby=b[1]-a[1];
      const L2 = abx*abx + aby*aby;
      const t = Math.max(0, Math.min(1, ((x-a[0])*abx + (y-a[1])*aby)/L2 ));
      const px = a[0] + abx*t, py=a[1] + aby*t;
      const d = Math.hypot(x-px,y-py);
      if (d < bestD){
        bestD = d; bestP=[px,py]; bestT=t;
        const segS = Track.sAccum[i-1] + Math.sqrt(L2)*t;
        bestS = segS;
        const L = Math.sqrt(L2)||1;
        const nx = -(aby/L), ny = (abx/L);
        bestN = [nx,ny];
      }
    }
    return {s: bestS, px: bestP[0], py: bestP[1], nx: bestN[0], ny: bestN[1], dist: bestD};
  }

  // ------------------------
  // Input handling
  // ------------------------
  const Keys = new Set();
  addEventListener('keydown', e=>{
    if (['Shift','Control',' '].includes(e.key)) e.preventDefault();
    Keys.add(e.key);
  });
  addEventListener('keyup', e=>{ Keys.delete(e.key); });

  // ------------------------
  // Game State
  // ------------------------
  const car1 = makeCar(getComputedStyle(document.documentElement).getPropertyValue('--p1').trim() || '#46d1ff');
  const car2 = makeCar(getComputedStyle(document.documentElement).getPropertyValue('--p2').trim() || '#ff6a66');
  const racers = [car1, car2];

  const cameras = [
    {x:0,y:0,zoom:1.2, mode:'chase', angle:0},
    {x:0,y:0,zoom:1.2, mode:'chase', angle:0},
  ];

  let raceStarted = false;
  let raceFinished = false;
  const startTime = {t: 0};

  // ------------------------
  // Initialization
  // ------------------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W=0,H=0;
  function resize(){
    W = canvas.width = Math.floor(innerWidth * devicePixelRatio);
    H = canvas.height = Math.floor(innerHeight * devicePixelRatio);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
  }
  addEventListener('resize', resize);
  resize();

  buildTrack();

  // Place cars at start
  function placeAtStart(car, laneOffset){
    const p0 = Track.points[0], p1 = Track.points[1];
    const yaw = Math.atan2(p1[1]-p0[1], p1[0]-p0[0]);
    const nx = -Math.sin(yaw), ny = Math.cos(yaw);
    car.x = p0[0] + nx*laneOffset;
    car.y = p0[1] + ny*laneOffset;
    car.yaw = yaw;
  }
  placeAtStart(car1, -Params.trackWidth*0.25);
  placeAtStart(car2,  Params.trackWidth*0.25);

  // ------------------------
  // Physics
  // ------------------------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function sign(v){ return v<0?-1:1; }

  function stepCar(car, dt){
    // Inputs
    const steerInput = car.steer;
    const delta = clamp(steerInput, -1, 1) * car.maxSteer;
    const throttle = clamp(car.throttle, 0, 1);
    const brake = clamp(car.brake, 0, 1);
    const ebrake = car.handbrake ? 1 : 0;

    // Local velocities
    const cos = Math.cos(car.yaw), sin = Math.sin(car.yaw);
    const ux = cos*car.vx + sin*car.vy;
    const uy = -sin*car.vx + cos*car.vy;
    const speed = Math.hypot(ux, uy);

    // Engine and brakes
    let Fx = throttle * (car.engineForce + (car.boostTimer>0? 2800:0));
    Fx -= car.drag * speed*speed * Math.sign(ux);
    Fx -= car.rr * Math.sign(ux);

    // Service brake reduces forward speed
    const brakeFx = - brake * car.brakeForce * Math.sign(ux);
    // Handbrake reduces rear longitudinal, and drastically lowers rear lateral capacity
    const ebrakeFx = - ebrake * car.handbrakeForce * Math.sign(ux);

    // Slip angles (bicycle model)
    const eps = 1e-4;
    const vf = uy + car.lf * car.yawRate;
    const vr = uy - car.lr * car.yawRate;
    const af = Math.atan2(vf, Math.max(eps, ux)) - delta;
    const ar = Math.atan2(vr, Math.max(eps, ux));

    // Effective friction (rear loses grip with handbrake; slight front loss under heavy braking)
    const muF = car.mu * (1 - 0.25*brake);
    const muR = car.mu * (1 - 0.65*ebrake);

    // Lateral forces with soft saturation to +/- mu*N
    const Fzf = car.mass * 9.81 * (car.lr/(car.lf+car.lr)); // static load split
    const Fzr = car.mass * 9.81 * (car.lf/(car.lf+car.lr));
    function latForce(C, a, mu, Fz){
      const Fy_lin = -C * a;
      const cap = mu * Fz;
      // smooth clamp
      return cap * Math.tanh(Fy_lin / Math.max(1, cap));
    }
    const Fyf = latForce(car.Cf, af, muF, Fzf);
    const Fyr = latForce(car.Cr, ar, muR, Fzr);

    // Longitudinal net
    let Fx_net = Fx + brakeFx + ebrakeFx;

    // Convert tire forces to body frame (front is steered by delta)
    const sinD = Math.sin(delta), cosD = Math.cos(delta);
    const Fx_total = Fx_net + (Fyf * sinD);
    const Fy_total = (Fyf * cosD) + Fyr;

    // Dynamics
    const ax_local = Fx_total / car.mass;
    const ay_local = Fy_total / car.mass;
    // Back to world
    const ax = cos*ax_local - sin*ay_local;
    const ay = sin*ax_local + cos*ay_local;

    car.vx += ax*dt;
    car.vy += ay*dt;
    // Yaw dynamics: moments around CG
    const Mz = car.lf * (Fyf * cosD) - car.lr * Fyr;
    car.yawRate += (Mz / car.Iz) * dt;

    // Integrate pose
    car.x += car.vx*dt;
    car.y += car.vy*dt;
    car.yaw += car.yawRate*dt;

    // Surface effects (off-road drag)
    const proj = projectToTrack(car.x, car.y);
    if (proj.dist > Params.trackWidth*0.5){
      // off road: heavy drag
      car.vx *= Math.exp(-Params.offroadFriction*dt);
      car.vy *= Math.exp(-Params.offroadFriction*dt);
    }

    // Guardrail collision (segment distance, simple bounce)
    const radius = 1.0; // car half-width for collision proxy
    for (const w of Track.walls){
      // Distance from car to segment
      const vxw = w.bx - w.ax, vyw = w.by - w.ay;
      const L2 = vxw*vxw + vyw*vyw;
      const t = clamp(((car.x - w.ax)*vxw + (car.y - w.ay)*vyw)/L2, 0, 1);
      const px = w.ax + vxw*t, py = w.ay + vyw*t;
      const dx = car.x - px, dy = car.y - py;
      const dist = Math.hypot(dx,dy);
      if (dist < radius){
        const nx = (dx/(dist||1)), ny = (dy/(dist||1));
        // push out
        car.x = px + nx*radius;
        car.y = py + ny*radius;
        // reflect velocity
        const vdotn = car.vx*nx + car.vy*ny;
        car.vx -= (1+Params.wallElasticity) * vdotn * nx;
        car.vy -= (1+Params.wallElasticity) * vdotn * ny;
        car.yawRate *= 0.6;
        car.wallHits++;
      }
    }

    // Visual trail and smoke
    const slipAngle = Math.atan2(uy, Math.max(1e-3, Math.abs(ux))) - 0; // body orientation vs motion
    if (speed > 2){
      car.trail.push({x:car.x, y:car.y, a:0.9});
      if (Math.abs(slipAngle) > 0.35 && speed > 6){
        for (let i=0;i<2;i++){
          const off = (Math.random()-0.5)*0.6;
          car.smoke.push({x:car.x - Math.cos(car.yaw)*0.8 + off, y:car.y - Math.sin(car.yaw)*0.8 + off, r:0.3, a:0.4});
        }
      }
    }
    while (car.trail.length > 240) car.trail.shift();
    for (const p of car.trail) p.a *= 0.985;
    for (const s of car.smoke){ s.r += 0.1; s.a *= 0.94; }
    while (car.smoke.length > 180) car.smoke.shift();

    // Scoring
    if (raceStarted && !car.finished){
      car.time += dt;
      const driftOK = (Math.abs(af - ar) > Params.driftAngleMin) && (speed > Params.driftSpeedMin);
      if (driftOK){
        // weighted by angle and speed
        car.driftScore += (Math.abs(af - ar) * 20 + speed*0.7) * dt * 10;
      }
      // Proximity to inside line (towards the normal inside if curvature suggests inside)
      const insideDist = proj.dist; // simple: closer to centerline is safe; we reward up to proximityMax
      const proxFactor = Math.max(0, (Params.proximityMax - insideDist)/Params.proximityMax);
      car.proximityScore += proxFactor * dt * 15;
      if (car.wallHits===0) car.cleanTime += dt;
    }

    // Boost
    if (car.boostTimer>0) car.boostTimer -= dt;
    if (car.clutchKick){
      car.boostTimer = 0.30; // short torque spike
      car.clutchKick = 0;
    }

    // Finish detection
    if (!car.finished && proj.s >= Track.length - 5){
      car.finished = true;
      car.driftScore += Params.finishBonus;
    }
  }

  // ------------------------
  // Game loop
  // ------------------------
  let acc = 0, last = performance.now();
  function frame(){
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    acc += dt;

    // Handle input each render, integrate fixed steps
    handleInputs();

    while (acc >= Params.dt){
      for (const car of racers) stepCar(car, Params.dt);
      acc -= Params.dt;
    }

    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ------------------------
  // Inputs mapping
  // ------------------------
  function handleInputs(){
    // Start when any throttle pressed
    if (!raceStarted && (Keys.has('w')||Keys.has('W')||Keys.has('ArrowUp'))) {
      raceStarted = true;
      startTime.t = performance.now();
    }
    // Car 1
    car1.throttle = (Keys.has('w')||Keys.has('W')) ? 1 : 0;
    car1.brake = (Keys.has('s')||Keys.has('S')) ? 1 : 0;
    const s1 = (Keys.has('a')||Keys.has('A')? -1:0) + (Keys.has('d')||Keys.has('D')? 1:0);
    car1.steer = clamp(car1.steer + s1 * car1.steerRate * Params.dt, -1, 1);
    car1.handbrake = Keys.has(' ');
    if (Keys.has('Shift')) car1.clutchKick = 1;
    if (Keys.has('c')||Keys.has('C')) cameras[0].mode = 'locked';
    else cameras[0].mode = 'chase';

    // Car 2
    car2.throttle = Keys.has('ArrowUp') ? 1 : 0;
    car2.brake = Keys.has('ArrowDown') ? 1 : 0;
    const s2 = (Keys.has('ArrowLeft')? -1:0) + (Keys.has('ArrowRight')? 1:0);
    car2.steer = clamp(car2.steer + s2 * car2.steerRate * Params.dt, -1, 1);
    car2.handbrake = Keys.has('Control') || Keys.has('Meta'); // Right Ctrl preferred
    if (Keys.has('ShiftRight')) car2.clutchKick = 1;
    if (Keys.has('m')||Keys.has('M')) cameras[1].mode = 'locked';
    else cameras[1].mode = 'chase';
  }

  // ------------------------
  // Rendering
  // ------------------------
  function draw(){
    ctx.clearRect(0,0,W,H);
    if (Params.split){
      const halfH = Math.floor(H/2);
      drawViewport(0, 0, W, halfH, car1, cameras[0], car2);
      drawViewport(0, halfH, W, H-halfH, car2, cameras[1], car1);
    } else {
      drawShared();
    }
    updateHUD();
  }

  function drawShared(){
    const midX = (car1.x + car2.x)/2, midY=(car1.y+car2.y)/2;
    const dx = car1.x - car2.x, dy = car1.y - car2.y;
    const sep = Math.hypot(dx,dy);
    const zoom = clamp(1.3 - sep*0.001, 0.7, 1.6);
    drawWorld(0,0,W,H, midX, midY, zoom, 0, [car1,car2]);
  }

  function drawViewport(x,y,w,h, focusCar, cam, other){
    // Camera follow
    if (cam.mode==='chase'){
      const lag = Params.chaseCamLag;
      const tx = focusCar.x + Math.cos(focusCar.yaw)*6;
      const ty = focusCar.y + Math.sin(focusCar.yaw)*6;
      cam.x += (tx - cam.x)*lag;
      cam.y += (ty - cam.y)*lag;
      cam.angle = focusCar.yaw;
      cam.zoom = 1.25;
    } else {
      // locked overhead
      cam.x += (focusCar.x - cam.x)*0.12;
      cam.y += (focusCar.y - cam.y)*0.12;
      cam.angle = 0;
      cam.zoom = 1.0;
    }
    drawWorld(x,y,w,h, cam.x, cam.y, cam.zoom, cam.angle, [focusCar, other]);
  }

  function drawWorld(x,y,w,h, cx, cy, zoom, angle, cars){
    ctx.save();
    ctx.beginPath();
    ctx.rect(x,y,w,h);
    ctx.clip();

    // Transform world -> screen
    ctx.translate(x + w/2, y + h/2);
    ctx.scale(1,1);
    ctx.rotate(-angle);
    const s = 22 * zoom; // pixels per meter
    ctx.scale(s, s);
    ctx.translate(-cx, -cy);

    // Background
    ctx.fillStyle = '#0b0f13';
    ctx.fillRect(cx - w/s, cy - h/s, 2*w/s, 2*h/s);

    // Road
    drawTrack();

    // Trees
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--tree') || '#0f3a2f';
    for (const t of Trees){
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
      ctx.fill();
    }

    // Cars and trails
    for (const car of cars){
      if (!car) continue;
      drawTrail(car);
    }
    for (const car of cars){
      if (!car) continue;
      drawCar(car);
    }

    ctx.restore();
  }

  function drawTrack(){
    // Road body
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'round';

    // Road fill (thick stroke)
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--road') || '#1a1f27';
    ctx.lineWidth = Params.trackWidth;
    ctx.beginPath();
    moveAlong(Track.points[0]);
    for (let i=1;i<Track.points.length;i++) lineTo(Track.points[i]);
    ctx.stroke();

    // Edges
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#aeb7c6';
    ctx.lineWidth = 0.4;
    ctx.setLineDash([2, 3]);
    ctx.beginPath();
    moveAlong(Track.points[0]);
    for (let i=1;i<Track.points.length;i++) lineTo(Track.points[i]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Center dashed lane
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--lane') || '#2b3240';
    ctx.lineWidth = 0.25;
    ctx.setLineDash([4, Params.laneMarkGap]);
    ctx.beginPath();
    moveAlong(Track.points[0]);
    for (let i=1;i<Track.points.length;i++) lineTo(Track.points[i]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Guardrails (thin light lines)
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall') || '#9aa3ad';
    ctx.lineWidth = 0.15;
    ctx.beginPath();
    for (const w of Track.walls){
      ctx.moveTo(w.ax, w.ay);
      ctx.lineTo(w.bx, w.by);
    }
    ctx.stroke();

    // Start and Finish banners
    drawBanner(Track.points[0], 0, 'START');
    drawBanner(Track.points[Track.points.length-1], Track.points.length-2, 'FINISH');
  }

  function moveAlong(p){ ctx.moveTo(p[0], p[1]); }
  function lineTo(p){ ctx.lineTo(p[0], p[1]); }

  function drawBanner(p, prevIndex, text){
    const dir = prevIndex>=0 ? tangentAt(prevIndex) : tangentAt(0);
    const nx = -dir[1], ny = dir[0];
    const a = [p[0] - nx*Params.trackWidth*0.52, p[1] - ny*Params.trackWidth*0.52];
    const b = [p[0] + nx*Params.trackWidth*0.52, p[1] + ny*Params.trackWidth*0.52];
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 0.2;
    ctx.beginPath();
    ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke();
    // text (as rectangles)
    ctx.fillStyle = '#ffffff';
    const m = (b[0]-a[0]), n=(b[1]-a[1]);
    const len = Math.hypot(m,n)||1;
    const ux = m/len, uy=n/len;
    const tx = a[0] + ux*0.8, ty = a[1] + uy*0.8;
    drawTinyText(text, tx, ty, ux, uy);
  }

  function drawTinyText(str, x, y, ux, uy){
    // bitmap-ish tiny glyphs
    const map = {
      'S': [1,1,1,1,0,0,1,1,1,0,0,1,1,1,1],
      'T': [1,1,1,0,1,0,0,1,0,0,1,0,0,1,0],
      'A': [0,1,0,1,0,1,1,1,1,1,0,1,1,0,1],
      'R': [1,1,0,1,0,1,1,1,0,1,0,1,1,0,1],
      'F': [1,1,1,1,0,0,1,1,1,1,0,0,1,0,0],
      'I': [1,1,1,0,1,0,0,1,0,0,1,0,1,1,1],
      'N': [1,0,1,1,1,1,1,1,1,1,0,1,1,0,1],
      'H': [1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
    };
    let offset = 0;
    for (const ch of str){
      const g = map[ch] || [];
      for (let i=0;i<15;i++){
        if (!g[i]) continue;
        const gx = i%3, gy = Math.floor(i/3);
        const px = x + ux*(gx*0.25 + offset) + (-uy)*(gy*0.22);
        const py = y + uy*(gx*0.25 + offset) + (ux)*(gy*0.22);
        ctx.fillRect(px,py, 0.18,0.18);
      }
      offset += 1.1;
    }
  }

  function drawCar(car){
    // Smoke
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--smoke') || 'rgba(240,240,240,0.08)';
    
    // Body
    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.yaw);
    const w = 1.8, l = 4.1;
    // chassis
    ctx.fillStyle = car.color;
    roundRect(-l*0.5, -w*0.5, l, w, 0.2);
    ctx.fill();
    // window
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    roundRect(-l*0.15, -w*0.35, l*0.42, w*0.7, 0.12);
    ctx.fill();
    // wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(-l*0.45, -w*0.52, 0.9, 0.22);
    ctx.fillRect(-l*0.45,  w*0.30, 0.9, 0.22);
    // headlights
    ctx.fillStyle = '#ffd';
    ctx.fillRect(l*0.48, -w*0.25, 0.08, 0.18);
    ctx.fillRect(l*0.48,  w*0.07, 0.08, 0.18);
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  function drawTrail(car){
    ctx.strokeStyle = car===car1 ? 'var(--trail1)' : 'var(--trail2)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    let first = true;
    for (const p of car.trail){
      if (first){ ctx.moveTo(p.x,p.y); first=false; }
      else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
  }

  // ------------------------
  // HUD
  // ------------------------
  function updateHUD(){
    const p1HUD = document.getElementById('p1HUD');
    const p2HUD = document.getElementById('p2HUD');
    function fmt(car){
      const speed = Math.hypot(car.vx,car.vy) * 3.6;
      const total = Math.floor(car.driftScore + car.proximityScore);
      const status = car.finished? 'FINISHED' : (raceStarted? 'RACING' : 'READY');
      return `Speed: ${speed.toFixed(0)} km/h | Drift: ${Math.floor(car.driftScore)} | Prox: ${Math.floor(car.proximityScore)} | Hits: ${car.wallHits} | ${status}`;
    }
    p1HUD.textContent = `P1 — ${fmt(car1)}`;
    p2HUD.textContent = `P2 — ${fmt(car2)}`;

    const raceInfo = document.getElementById('raceInfo');
    const t = raceStarted ? ((performance.now()-startTime.t)/1000) : 0;
    const lead = leader();
    const leadTxt = lead===0? 'P1 leads' : lead===1? 'P2 leads' : 'Neck and neck';
    raceInfo.textContent = `Course: Izumo Touge | Length: ${(Track.length/1000).toFixed(2)} km | Time: ${t.toFixed(1)} s | ${leadTxt}`;
  }

  function leader(){
    // Who is further along s; tie => -1
    const pr1 = projectToTrack(car1.x,car1.y).s;
    const pr2 = projectToTrack(car2.x,car2.y).s;
    if (Math.abs(pr1-pr2)<2) return -1;
    return pr1>pr2?0:1;
  }

  // ------------------------
  // Done
  // ------------------------

})();
</script>
</body>
</html>
